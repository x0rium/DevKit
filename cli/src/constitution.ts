import { readFileSync, writeFileSync, existsSync, readdirSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';

export interface ConstitutionResult {
    generated: boolean;
    invariantsCount: number;
    uxInvariantsCount: number;
    decisionsCount: number;
    outputPath: string;
    error?: string;
}

function extractSections(content: string, prefix: string): string[] {
    const sections: string[] = [];
    const regex = new RegExp(`^## ${prefix}(.+)`, 'gm');
    let match: RegExpExecArray | null;

    while ((match = regex.exec(content)) !== null) {
        // Extract from this ## to the next ##
        const start = match.index;
        const rest = content.slice(start);
        const nextSection = rest.indexOf('\n## ', 3);
        const section = nextSection > 0 ? rest.slice(0, nextSection) : rest;
        sections.push(section.trim());
    }

    return sections;
}

function readIfExists(path: string): string | null {
    if (!existsSync(path)) return null;
    return readFileSync(path, 'utf-8');
}

export function generateConstitution(cwd: string): ConstitutionResult {
    const devkitDir = join(cwd, '.devkit');
    const archDir = join(devkitDir, 'arch');
    const productDir = join(devkitDir, 'product');
    const outputPath = join(archDir, 'constitution.md');

    // Check preconditions
    const invariantsContent = readIfExists(join(archDir, 'invariants.md'));
    const uxInvariantsContent = readIfExists(join(productDir, 'ux_invariants.md'));

    if (!invariantsContent && !uxInvariantsContent) {
        return {
            generated: false,
            invariantsCount: 0,
            uxInvariantsCount: 0,
            decisionsCount: 0,
            outputPath,
            error: 'No invariants found. Create invariants.md in .devkit/arch/ or ux_invariants.md in .devkit/product/',
        };
    }

    const lines: string[] = [];
    const now = new Date().toISOString().split('T')[0];

    // Ensure arch directory exists
    mkdirSync(archDir, { recursive: true });

    lines.push('# Constitution');
    lines.push('');
    lines.push('> Auto-generated by DevKit CLI. DO NOT EDIT MANUALLY.');
    lines.push(`> Generated: ${now}`);
    lines.push(`> Source: .devkit/arch/invariants.md + .devkit/product/ux_invariants.md + .devkit/arch/decisions/`);
    lines.push('');

    // === Technical Invariants ===
    let invariantsCount = 0;
    if (invariantsContent) {
        const sections = extractSections(invariantsContent, 'I\\d+');
        invariantsCount = sections.length;

        if (sections.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## Technical Invariants');
            lines.push('');
            lines.push('The system MUST guarantee the following:');
            lines.push('');

            for (const section of sections) {
                // Extract key fields
                const stmtMatch = section.match(/STATEMENT:\s*(.+)/);
                const failMatch = section.match(/FAILURE_MODE:\s*(.+)/);
                const headerMatch = section.match(/^## (.+)/);

                if (headerMatch && stmtMatch) {
                    lines.push(`### ${headerMatch[1]}`);
                    lines.push(`- **Guarantee**: ${stmtMatch[1]}`);
                    if (failMatch) {
                        lines.push(`- **On violation**: ${failMatch[1]}`);
                    }
                    lines.push('');
                }
            }
        }
    }

    // === UX Invariants ===
    let uxInvariantsCount = 0;
    if (uxInvariantsContent) {
        const sections = extractSections(uxInvariantsContent, 'U\\d+');
        uxInvariantsCount = sections.length;

        if (sections.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## UX Invariants');
            lines.push('');
            lines.push('The system MUST provide the following user experience guarantees:');
            lines.push('');

            for (const section of sections) {
                const stmtMatch = section.match(/STATEMENT:\s*(.+)/);
                const priorityMatch = section.match(/PRIORITY:\s*(.+)/);
                const headerMatch = section.match(/^## (.+)/);

                if (headerMatch && stmtMatch) {
                    const priority = priorityMatch ? ` [${priorityMatch[1]}]` : '';
                    lines.push(`### ${headerMatch[1]}${priority}`);
                    lines.push(`- **Promise**: ${stmtMatch[1]}`);
                    lines.push('');
                }
            }
        }
    }

    // === Architecture Decisions ===
    let decisionsCount = 0;
    const decisionsDir = join(archDir, 'decisions');
    if (existsSync(decisionsDir)) {
        const files = readdirSync(decisionsDir)
            .filter(f => f.endsWith('.md') && f.startsWith('ADR-'))
            .sort();

        decisionsCount = files.length;

        if (files.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## Architecture Decisions');
            lines.push('');

            for (const file of files) {
                const content = readFileSync(join(decisionsDir, file), 'utf-8');
                const titleMatch = content.match(/^# (.+)/m);
                const decisionMatch = content.match(/DECISION:\s*(.+)/);
                const rationaleMatch = content.match(/RATIONALE:\s*(.+)/);

                const title = titleMatch ? titleMatch[1] : file.replace('.md', '');
                lines.push(`### ${title}`);
                if (decisionMatch) lines.push(`- **Decision**: ${decisionMatch[1]}`);
                if (rationaleMatch) lines.push(`- **Rationale**: ${rationaleMatch[1]}`);
                lines.push('');
            }
        }
    }

    // === Active RFCs ===
    if (existsSync(decisionsDir)) {
        const rfcs = readdirSync(decisionsDir)
            .filter(f => f.endsWith('.md') && f.startsWith('RFC-'))
            .sort();

        if (rfcs.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## Active RFCs');
            lines.push('');

            for (const file of rfcs) {
                const content = readFileSync(join(decisionsDir, file), 'utf-8');
                const titleMatch = content.match(/^# (.+)/m);
                const statusMatch = content.match(/STATUS:\s*(.+)/);
                const title = titleMatch ? titleMatch[1] : file.replace('.md', '');
                const status = statusMatch ? statusMatch[1] : 'unknown';
                lines.push(`- **${title}** — ${status}`);
            }
            lines.push('');
        }
    }

    // === Footer ===
    lines.push('---');
    lines.push('');
    lines.push('## Development Guidelines');
    lines.push('');
    lines.push('1. Any deviation from the invariants above requires an RFC through ArchKit');
    lines.push('2. New requirements that touch invariants must go through impact analysis');
    lines.push('3. Test contracts in QAKit map 1:1 to invariants — every invariant must be testable');
    lines.push('4. This file is regenerated when invariants or decisions change — do not edit manually');
    lines.push('');

    const output = lines.join('\n');
    writeFileSync(outputPath, output, 'utf-8');

    return {
        generated: true,
        invariantsCount,
        uxInvariantsCount,
        decisionsCount,
        outputPath,
    };
}

export function syncConstitution(cwd: string): { synced: boolean; from: string; to: string; error?: string } {
    const from = join(cwd, '.devkit', 'arch', 'constitution.md');
    const specifyDir = join(cwd, '.specify');
    const to = join(specifyDir, 'constitution.md');

    if (!existsSync(from)) {
        return { synced: false, from, to, error: 'constitution.md not found. Run "devkit generate-constitution" first.' };
    }

    if (!existsSync(specifyDir)) {
        mkdirSync(specifyDir, { recursive: true });
    }

    const content = readFileSync(from, 'utf-8');
    writeFileSync(to, content, 'utf-8');

    return { synced: true, from: '.devkit/arch/constitution.md', to: '.specify/constitution.md' };
}
