import { readFileSync, writeFileSync, existsSync, readdirSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';

export interface ConstitutionResult {
    generated: boolean;
    invariantsCount: number;
    uxInvariantsCount: number;
    decisionsCount: number;
    outputPath: string;
    error?: string;
}

function extractSections(content: string, prefix: string): string[] {
    const sections: string[] = [];
    const regex = new RegExp(`^## ${prefix}(.+)`, 'gm');
    let match: RegExpExecArray | null;

    while ((match = regex.exec(content)) !== null) {
        // Extract from this ## to the next ##
        const start = match.index;
        const rest = content.slice(start);
        const nextSection = rest.indexOf('\n## ', 3);
        const section = nextSection > 0 ? rest.slice(0, nextSection) : rest;
        sections.push(section.trim());
    }

    return sections;
}

function readIfExists(path: string): string | null {
    if (!existsSync(path)) return null;
    return readFileSync(path, 'utf-8');
}

export function generateConstitution(cwd: string): ConstitutionResult {
    const devkitDir = join(cwd, '.devkit');
    const archDir = join(devkitDir, 'arch');
    const productDir = join(devkitDir, 'product');
    const outputPath = join(archDir, 'constitution.md');

    // Check preconditions
    const invariantsContent = readIfExists(join(archDir, 'invariants.md'));
    const uxInvariantsContent = readIfExists(join(productDir, 'ux_invariants.md'));

    if (!invariantsContent && !uxInvariantsContent) {
        return {
            generated: false,
            invariantsCount: 0,
            uxInvariantsCount: 0,
            decisionsCount: 0,
            outputPath,
            error: 'No invariants found. Create invariants.md in .devkit/arch/ or ux_invariants.md in .devkit/product/',
        };
    }

    const lines: string[] = [];
    const now = new Date().toISOString().split('T')[0];

    // Ensure arch directory exists
    mkdirSync(archDir, { recursive: true });

    lines.push('# Constitution');
    lines.push('');
    lines.push('> Auto-generated by DevKit CLI. DO NOT EDIT MANUALLY.');
    lines.push(`> Generated: ${now}`);
    lines.push(`> Source: .devkit/arch/invariants.md + .devkit/product/ux_invariants.md + .devkit/arch/decisions/`);
    lines.push('');

    // === Technical Invariants ===
    let invariantsCount = 0;
    if (invariantsContent) {
        const sections = extractSections(invariantsContent, 'I\\d+');
        invariantsCount = sections.length;

        if (sections.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## Technical Invariants');
            lines.push('');
            lines.push('The system MUST guarantee the following:');
            lines.push('');

            for (const section of sections) {
                // Extract key fields
                const stmtMatch = section.match(/STATEMENT:\s*(.+)/);
                const failMatch = section.match(/FAILURE_MODE:\s*(.+)/);
                const headerMatch = section.match(/^## (.+)/);

                if (headerMatch && stmtMatch) {
                    lines.push(`### ${headerMatch[1]}`);
                    lines.push(`- **Guarantee**: ${stmtMatch[1]}`);
                    if (failMatch) {
                        lines.push(`- **On violation**: ${failMatch[1]}`);
                    }
                    lines.push('');
                }
            }
        }
    }

    // === UX Invariants ===
    let uxInvariantsCount = 0;
    if (uxInvariantsContent) {
        const sections = extractSections(uxInvariantsContent, 'U\\d+');
        uxInvariantsCount = sections.length;

        if (sections.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## UX Invariants');
            lines.push('');
            lines.push('The system MUST provide the following user experience guarantees:');
            lines.push('');

            for (const section of sections) {
                const stmtMatch = section.match(/STATEMENT:\s*(.+)/);
                const priorityMatch = section.match(/PRIORITY:\s*(.+)/);
                const headerMatch = section.match(/^## (.+)/);

                if (headerMatch && stmtMatch) {
                    const priority = priorityMatch ? ` [${priorityMatch[1]}]` : '';
                    lines.push(`### ${headerMatch[1]}${priority}`);
                    lines.push(`- **Promise**: ${stmtMatch[1]}`);
                    lines.push('');
                }
            }
        }
    }

    // === Architecture Decisions ===
    let decisionsCount = 0;
    const decisionsDir = join(archDir, 'decisions');
    if (existsSync(decisionsDir)) {
        const files = readdirSync(decisionsDir)
            .filter(f => f.endsWith('.md') && f.startsWith('ADR-'))
            .sort();

        decisionsCount = files.length;

        if (files.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## Architecture Decisions');
            lines.push('');

            for (const file of files) {
                const content = readFileSync(join(decisionsDir, file), 'utf-8');
                const titleMatch = content.match(/^# (.+)/m);
                const decisionMatch = content.match(/DECISION:\s*(.+)/);
                const rationaleMatch = content.match(/RATIONALE:\s*(.+)/);

                const title = titleMatch ? titleMatch[1] : file.replace('.md', '');
                lines.push(`### ${title}`);
                if (decisionMatch) lines.push(`- **Decision**: ${decisionMatch[1]}`);
                if (rationaleMatch) lines.push(`- **Rationale**: ${rationaleMatch[1]}`);
                lines.push('');
            }
        }
    }

    // === Active RFCs ===
    if (existsSync(decisionsDir)) {
        const rfcs = readdirSync(decisionsDir)
            .filter(f => f.endsWith('.md') && f.startsWith('RFC-'))
            .sort();

        if (rfcs.length > 0) {
            lines.push('---');
            lines.push('');
            lines.push('## Active RFCs');
            lines.push('');

            for (const file of rfcs) {
                const content = readFileSync(join(decisionsDir, file), 'utf-8');
                const titleMatch = content.match(/^# (.+)/m);
                const statusMatch = content.match(/STATUS:\s*(.+)/);
                const title = titleMatch ? titleMatch[1] : file.replace('.md', '');
                const status = statusMatch ? statusMatch[1] : 'unknown';
                lines.push(`- **${title}** — ${status}`);
            }
            lines.push('');
        }
    }

    // === Footer ===
    lines.push('---');
    lines.push('');
    lines.push('## Development Guidelines');
    lines.push('');
    lines.push('1. Any deviation from the invariants above requires an RFC through ArchKit');
    lines.push('2. New requirements that touch invariants must go through impact analysis');
    lines.push('3. Test contracts in QAKit map 1:1 to invariants — every invariant must be testable');
    lines.push('4. This file is regenerated when invariants or decisions change — do not edit manually');
    lines.push('');

    const output = lines.join('\n');
    writeFileSync(outputPath, output, 'utf-8');

    return {
        generated: true,
        invariantsCount,
        uxInvariantsCount,
        decisionsCount,
        outputPath,
    };
}

function transformToSpecKitFormat(content: string, cwd: string): string {
    const lines: string[] = [];
    const now = new Date().toISOString().split('T')[0];

    // Detect project name from package.json or directory
    let projectName = 'Project';
    const pkgPath = join(cwd, 'package.json');
    if (existsSync(pkgPath)) {
        try {
            const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
            if (pkg.name) projectName = pkg.name;
        } catch { /* ignore */ }
    }

    lines.push(`# ${projectName} Constitution`);
    lines.push('');
    lines.push('> Transformed from DevKit invariants. Regenerate with: `devkit generate-constitution && devkit sync`');
    lines.push('');
    lines.push('## Core Principles');
    lines.push('');

    // Extract technical invariants as principles
    const techSections = content.split(/^### /m).slice(1);
    let principleNum = 0;

    for (const section of techSections) {
        const headerLine = section.split('\n')[0]?.trim() ?? '';
        // Find the guarantee/promise line
        const guaranteeMatch = section.match(/\*\*Guarantee\*\*:\s*(.+)/);
        const promiseMatch = section.match(/\*\*Promise\*\*:\s*(.+)/);
        const statement = guaranteeMatch?.[1] ?? promiseMatch?.[1];

        if (headerLine && statement) {
            principleNum++;
            lines.push(`### ${headerLine}`);
            // If statement already reads as a complete rule, use as-is; otherwise prefix with MUST
            const normalized = statement.trim();
            if (/^(the system|all |every |no |any )/i.test(normalized) || /\bMUST\b|\bSHALL\b/i.test(normalized)) {
                lines.push(normalized);
            } else {
                lines.push(`The system MUST: ${normalized}`);
            }
            lines.push('');
        }
    }

    // Governance
    lines.push('## Governance');
    lines.push('');
    lines.push('- Any deviation from principles above requires an RFC through ArchKit (`devkit rfc`)');
    lines.push('- New requirements touching invariants must go through impact analysis (`devkit impact`)');
    lines.push('- Test contracts in QAKit map 1:1 to principles — every principle must be testable');
    lines.push('- This constitution is regenerated when invariants or decisions change — do not edit manually');
    lines.push('');
    lines.push(`**Version**: 1.0.0 | **Ratified**: ${now} | **Last Amended**: ${now}`);
    lines.push('');

    return lines.join('\n');
}

export function syncConstitution(cwd: string): { synced: boolean; from: string; to: string; error?: string } {
    const from = join(cwd, '.devkit', 'arch', 'constitution.md');
    const memoryDir = join(cwd, '.specify', 'memory');
    const to = join(memoryDir, 'constitution.md');

    if (!existsSync(from)) {
        return { synced: false, from, to, error: 'constitution.md not found. Run "devkit generate-constitution" first.' };
    }

    mkdirSync(memoryDir, { recursive: true });

    const devkitContent = readFileSync(from, 'utf-8');
    const specKitContent = transformToSpecKitFormat(devkitContent, cwd);
    writeFileSync(to, specKitContent, 'utf-8');

    return { synced: true, from: '.devkit/arch/constitution.md', to: '.specify/memory/constitution.md' };
}
